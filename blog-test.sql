-- phpMyAdmin SQL Dump
-- version 4.6.6deb5
-- https://www.phpmyadmin.net/
--
-- Хост: localhost:3306
-- Время создания: Июн 15 2019 г., 07:06
-- Версия сервера: 5.7.26-0ubuntu0.19.04.1
-- Версия PHP: 7.2.19-0ubuntu0.19.04.1

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `blog-test`
--

-- --------------------------------------------------------

--
-- Структура таблицы `migrations`
--

CREATE TABLE `migrations` (
  `id` int(10) UNSIGNED NOT NULL,
  `migration` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `batch` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `migrations`
--

INSERT INTO `migrations` (`id`, `migration`, `batch`) VALUES
(6, '2014_10_12_000000_create_users_table', 1),
(7, '2014_10_12_100000_create_password_resets_table', 1),
(8, '2019_05_13_150238_create_posts_table', 1),
(9, '2019_05_14_145917_create_article_tags_table', 1),
(10, '2019_05_18_121422_create_tags_table', 2),
(11, '2019_05_19_104302_create_tags_table', 3);

-- --------------------------------------------------------

--
-- Структура таблицы `password_resets`
--

CREATE TABLE `password_resets` (
  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `token` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- --------------------------------------------------------

--
-- Структура таблицы `posts`
--

CREATE TABLE `posts` (
  `id` int(10) UNSIGNED NOT NULL,
  `title` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `body` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `posts`
--

INSERT INTO `posts` (`id`, `title`, `body`, `created_at`, `updated_at`) VALUES
(3, 'Свежий воздух на Марсе: согнуть молекулу СО2 и получить кислород', 'Что мы вспоминаем при словосочетании «научная фантастика»? Конечно же роботов, летающие машины, исследование ранее неизведанных уголков Вселенной, инопланетян и еще целую вереницу сюжетов. Среди них особое место всегда занимала тема заселения другой планеты, то ли от уверенности в неизбежности гибели собственной, то ли от желания радикально сменить обстановку. Первой претенденткой на звание Земля 2.0 всегда был Марс, холодный и безжизненный. На данный момент собрать чемоданы и улететь на Марс в отпуск недельки на две пока не представляется возможным, но это абсолютно реально и выполнимо, вопрос только как скоро. Самым же бросающимся в глаза минусом Марса (за исключением отсутствия нормального интернета) является отсутствие приемлемой для жизни атмосферы. Прилететь в место назначения, выйти из летательного аппарата и вдохнуть полной грудью, ощутив всю свежесть местного воздуха — это не про Марс. Но так будет не всегда.\r\n\r\nСегодня мы с вами познакомимся с исследованием, в котором описывается новый метод выработки кислорода посредством необычной химической реакции. Как ученые вырабатывали молекулярный кислород из СО2, насколько эффективен этот метод и где его можно применять кроме межпланетных путешествий? Ответы на эти вопросы мы будем искать в докладе ученых. Поехали.\r\n\r\nОснова исследования\r\n\r\nЧеловеку для жизни нужно всего три вещи: еда, вода и воздух, в котором будет достаточно кислорода. Это наши с вами первичные нужды (да, интернета нет в этом списке). Но кислород просто так на дороге не валяется, особенно за пределами нашей любимой планеты. Следовательно, если мы хотим отправиться куда-то, нам необходимо брать его с собой и использовать различные устройства для очистки воздуха и повторного его использования. Вся эта радость занимает уйму места, и рано или поздно кислород исчерпается. А пополнить запасы в космосе или на Марсе будет, мягко говоря, проблематично.\r\n\r\nОднако относительно недавно ученые обнаружили достаточно большое количество кислорода в комете 67P/CG6, что побудило их задать вполне очевидный вопрос — откуда он там взялся? Кислород в таких телах как кометы является результатом возникающей в экстремальных условиях абиотической реакции, в процессе которой из H2O, CO2, CO и т.д. выделяется O2 (кислород). Ученые утверждают, что такими реакциями можно объяснить наличие кислорода в кометах, верхних слоях атмосферы Марса и в ранней атмосфере Земли. Человек же может применить такую химическую реакцию для выработки О2 из СО2, что позволит сделать Марс пригодным для жизни.\r\n\r\nЕсли очень утрировано и кратко, то упомянутая выше реакция это разложение СО2 на компоненты: C + O2. Другими словами, диссоциация. \r\n\r\nДиссоциация CO2 может проходить по нескольким сценариям в зависимости от доступной для реакции энергии. Меньше всего энергии требует частичная диссоциация CO2 → CO + O (5,43 или 7,56 эВ). Также есть полная диссоциация CO2 → C + O + O, требующая 16,46 эВ. И, самая любопытная, экзотическая диссоциация, когда CO2 распадается на C и O2. Расчеты показывают, что подобная реакция протекает на поверхности потенциальной энергии основного состояния, сначала образуя циклическое промежуточное CO2 соединение [c-CO2(1A1)], которое затем перестраивается в коллинеарное промежуточное соединение COO (1Σ+) на пути к диссоциации в С + О2.\r\n\r\nТакая реакция возможна, если «согнуть» молекулу таким образом, чтобы два атома О стали максимально близки друг к другу. На это требуется 6 эВ внутренней энергии. И, согласитесь, сколько бы силачи не гнули металлические прутья, согнуть молекулу будет куда сложнее.\r\n\r\nСогнуть молекулу могут помочь переходы в электронно-возбужденные и анионные состояния СО2. Ученые напоминают, что недавние опыты их коллег показали, что применение VUV (вакуумный ультрафиолет) фотовозбуждения и присоединения электронов позволяет достичь диссоциации CO2 на C(3P) + O2(X3Σg-). Однако никто ранее не изучал этот экзотический процесс на достаточно детальном уровне. А все потому, что в результате таких опытов не было обнаружено ионизированных продуктов O2. Но, как мы знаем, не найти что-то еще не значит, что его нет вовсе.\r\n\r\nПосему в рассматриваемом нами сегодня исследовании ученые применили методы рассеяния ионного пучка наряду с математическим моделированием, чтобы продемонстрировать новый способ активации прямого восстановления CO2 до O2 с обнаружением ионизированных продуктов O2. Данный процесс содержит ранее неизвестный внутримолекулярный путь реакции, который протекает при активных столкновениях ионов и поверхности CO2. Самое удивительное это отсутствие зависимости данной реакции от природы и температуры поверхности.\r\n\r\nРезультаты исследования\r\n\r\nПервым делом ученые демонстрируют образование О2 в гипертермических столкновениях CO2+/Au путем построения графиков распределения кинетической энергии трех рассеянный молекулярных ионных продуктов (CO2+, O2+ и O2−) для различных энергий падающего CO2+ (E0). При E0 <80 эВ был обнаружен очень слабый сигнал рассеянного CO2+ (1а, график слева).\r\n\r\n\r\nИзображение №1\r\n\r\nПик энергии выходящего CO2+ пропорционален E0, то есть имеет место баллистический или импульсный отскок от поверхности, что исключает физическое распыление. Ученые считают, что наблюдение за «динамическим» сигналом CO2+ крайне важно, ибо является доказательством того, что некоторое количество CO2 выживает при поверхностном столкновении. Кроме этого можно определить последовательность столкновения составляющих атомов. Кроме CO2+ также наблюдались сигналы рассеянных ионов O2 (1b, 1c / график в центре и справа). При этом энергии выходящих O2+ и O2− представляют большую долю энергии падающих частиц (57%) и равномерно возрастают параллельно E0 в более широком диапазоне, чем рассеянный CO2+. Максимальный сигнал ионов O2 наблюдался при E0 ~ 100 эВ.\r\n\r\nИсследователи называют обнаружение ионных продуктов О2 удивительным, так как ни распыление поверхностных O2, ни реакции абстракции атома O не могут объяснить образование этих ионов. А все потому, что оба эти механизма производили бы O2 при гораздо более низких энергиях на выходе, чем наблюдалось. Логично предположить, что здесь замешана та самая диссоциация CO2.\r\n\r\nИ частичная, и полная диссоциация СО2 хорошо согласуется с другими обнаруженными ионными продуктами (СО+, СО−, О+, О− и С+). А энергия выходящего CO+, CO− и O− изменяется параллельно с энергией падающих частиц, что согласуется с динамическим образованием при поверхностном столкновении.\r\n\r\nНо пики O+ и C+ показывают крайне малую зависимость от E0, что указывает на различное происхождение, то есть на распыление. Подтверждением полной диссоциации являются рассеянные продукты C+, проявляющиеся при E0> 80 эВ.\r\n\r\nДалее ученые применили кинематику для описания механизма рассеяния.\r\n\r\nБинарная теория соударений (БТС) позволяет рассчитать кинематический фактор, определяемый как доля энергии падающих частиц, удерживаемая рассеянным продуктом, выходящим из поверхности. В случае простейшей модели CO2+ рассеивается как целая молекула, т.е. как твердая сфера с атомной массой 44 Да. В таком случае БТС предсказывает кинематический коэффициент 0,6349, что довольно слабо соотносится с данными (2а).\r\n\r\n\r\nИзображение №2\r\n\r\nСледом ученые применили модель, в которой атом О сначала сталкивается с поверхностным атомом Au, а затем происходит второе столкновение фрагмента CO без быстрой диссоциации молекулы CO2. Применение БТС к данной модели последовательных столкновений дает кинематический коэффициент 0,7870, который отлично согласуется с данными по энергии выходящего CO2+ (черная линия на 2a). На графике 2а также показаны энергии других выходящих рассеянных ионных продуктов.\r\n\r\nОсновным потенциальным источником таких продуктов можно назвать частичную или полную диссоциацию CO2 и поверхностное распыление адсорбированных фрагментов CO2. Несмотря на то, что некоторое распыление действительно наблюдается при высоких значениях E0 (> 140 эВ), кинематический анализ данных по энергии выходящих частиц дает убедительные доказательства наличия именно импульсной диссоциации молекулы CO2.\r\n\r\nДалее ученые провели анализ скорости наблюдаемых рассеянных частиц. \r\n\r\nНа изображении 2b показано сравнение пиков распределения ионов при E0 = 56,4 эВ. Как мы видим, скорости выхода рассеянного CO+, O2+, O2− и более медленной части распределения O− перекрывают друг друга, что указывает на общее происхождение. Однако распределение O− заметно шире, распространяясь на более высокие скорости на выходе, что может говорить об альтернативном происхождении. Ионные продукты O2 выходят со скоростями ниже, чем CO2+ ввиду неупругости, возникающей из-за разрыва химических связей и нерезонансной поверхностной ионизации.\r\n\r\nВышеописанный кинематический анализ, как говорят ученые, дал исчерпывающие доказательства того, что некоторые молекулы CO2 рассеиваются не поврежденными после двухступенчатого последовательного столкновения фрагментов O и CO. Однако все равно остаются вопросы, касающиеся различных аспектов механизма образования O2. \r\n\r\nПосле проведения экспериментов остается ряд вопросов. Во-первых, осталось неясно образуется ли O2 с помощью электронного адиабатического или неадиабатического механизма. Во-вторых, неизвестны пути столкновений, которые лежат в основе распределения скоростей на выходе ионных фрагментов. В-третьих, неизвестно сколько образуется нейтрального O2.\r\n\r\nПрояснить ситуацию в таком случае может моделирование, а именно метод классической молекулярной динамики (метод МД). \r\n\r\nВ моделировании траектории рассеяния CO2 на Au(111) была применена геометрия рассеяния, наблюдаемая в эксперименте. При этом предполагается, что CO2 выделяется на поверхности потенциальной энергии синглетного электрона в случае нейтрализации поступающих ионов CO2+ перед жестким столкновением.\r\n\r\nБыстрая нейтрализация происходит посредством резонансного туннелирования электронов от поверхности металла к молекулярному катиону, поскольку молекулярный уровень CO2 (-13,8 эВ) находится в пределах занятой зоны Au (от -5,3 до -15,3 эВ). В моделировании также учитывались и переносы электронов с/на поверхность, чтобы учесть ионизацию нейтральных продуктов соударений.\r\n\r\nНа изображении 2с показаны рассчитанные значения энергии выходящих частиц.\r\n\r\nБыло обнаружено, что незначительное число СО2 сохраняет целостность при E0 > 80 эВ, что согласуется с отсутствием сигнала при этих энергиях во время практических опытов. Данные, полученные посредством моделирования, отлично согласуются с экспериментальными, что легко увидеть сравнив графики 2а (эксперимент) и 2с (моделирование).\r\n\r\nПомимо этого согласования экспериментов и моделирования проявляется и в сравнении скорости выходных ионов при E0 = 56,4 эВ (2d). И модель, и эксперимент показывают расширение распределения скоростей CO+ и O–. Также было подтверждено, что распределения O2+ и O2– аналогичны катиону, выходящему медленнее, чем анион. Кроме того в обоих случаях было установлено, что CO2+ выходит с большей скоростью, чем ионизированные продукты O2.\r\n\r\nСледовательно, использование данной методики моделирования может дать достаточно точные данные касательно механизма реакции прямого преобразования CO2 в O2.\r\n\r\nВо время основного этапа моделирования было воссоздано по 20000 траектории столкновения CO2-на-Au при разных значениях энергии выходящих частиц. В результате было получено несколько вариантов продуктов диссоциации, в том числе и O2 (3а).\r\n\r\n\r\nИзображение №3\r\n\r\nНа изображении 3b показана репрезентативная траектория, результатом которой является образование O2. В результате импульсной передачи энергии во время столкновения внутри отскакивающего СО2 происходит существенная внутримолекулярная перегруппировка. Расстояние O – O уменьшается, а расстояние C – O увеличивается, достигая пика, когда CO2 приобретает треугольную конфигурацию с почти равными длинами связей. Такой сильно изогнутый промежуточный CO2 продукт обладает значительным количеством внутренней энергии и быстро диссоциирует, в результате чего образуется свободный атом C и колебательно горячая молекула O2.\r\n\r\n\r\nПроцесс разделения CO2 на свободный атом C и колебательно горячую молекулу O2.\r\n\r\nСтоит отметить, что описанный выше механизм разделения полностью согласуется с выводами кинематической модели, использованной ранее.\r\n\r\nРасчеты показали, что примерно 5% от всех траекторий приводят к сильно изогнутому промежуточному состоянию СО2, что является одной из стадий выделения О2. Данное состояние фрагментируется в основном посредством частичной диссоциации (51%), после чего снова следует полная диссоциация, но уже с более высоким результатом (33%).\r\n\r\n\r\nИзображение №4\r\n\r\nУченые отмечают, что из всех изогнутых молекул СО2 лишь 13 процентов производят кислород. То есть общий результат диссоциации CO2 → C + O2 составляет 0,6% при E0 = 56,4 эВ. Если же увеличить энергию падающих частиц, то можно получить О2 до 0,8 ± 0,2% при E0 ~ 70 ± 15 эВ (синяя линия на изображении №4).\r\n\r\nКроме того, доля O2-образующих траекторий существенно возрастает, когда достигается сильно изогнутое промежуточное состояние CO2 (зеленая линия), достигая максимума в 13% при E0 ~ 55 ± 10 эВ. Меньший суммарный выход нейтрального O2 обусловлен тем, что лишь небольшая доля линейных молекул CO2 достигает сильно изогнутого состояния (красная линия). Если же специально изменить ориентацию поступающих молекул СО2 (ось, параллельная поверхности), то в результате можно получить на 2% больше О2 (пунктирная зеленая линия).\r\n\r\nДля более детального ознакомления с нюансами исследования рекомендую заглянуть в доклад ученых.\r\n\r\nЭпилог\r\n\r\nДанный труд продемонстрировал, что посредством нестандартных химических реакций можно получить кислород из углекислого газа. Никто не будет спорить, что подобная методика требует дальнейших доработок и усовершенствований. Однако нельзя отрицать и факт того, что сей труд действительно открывает новые возможности для межпланетных путешествий, колонизации Марса и не только. На нашей родной планете также есть проблема с кислородом и углекислым газом. Скорее с последним, ибо его объем значительно возрос с момента индустриализации. А учитывая то, что СО2 является одним из основных виновников глобального потепления, уменьшение его количества и получение из него кислорода звучит как очень заманчивая идея. Раз уж мы никак пока что не можем обойтись без заводов, фабрик, машин с двигателями внутреннего сгорания и прочего, то новые методы очистки нашей атмосферы не просто нужны, а крайне необходимы. Ибо путешествия на далекие планеты это конечно круто, но до массового переезда на Марс еще очень и очень далеко, посему стоит больше думать о Земле, на которой мы живем, чем о Марсе, о котором мечтаем.', '2019-06-04 18:00:00', '2019-06-05 08:46:31'),
(4, 'Новое в PHP 7.4', 'Новая версия PHP хоть и является минорной, но уже несёт множество новых, без преувеличения, крутых возможностей как для синтаксиса языка, так и для его производительности. Список новшеств не окончательный, но основные изменения уже внесены и приняты. Релиз планируется на декабрь 2019 года.\r\n \r\n\r\n \r\nКлючевые изменения грядущей версии:\r\n\r\nТипизированные свойства классов\r\nПредзагрузка для улучшения производительности\r\nСтрелочные функции для короткой записи анонимных функций\r\nПрисваивающий оператор объединения с null (??=)\r\nКовариантность/контравариантность в сигнатурах унаследованных методов\r\nИнтерфейс внешних функций, открывающий новые возможности для разработки расширений на PHP\r\nОператор распаковки в массивах\r\n\r\nПодробнее об этих и других изменениях читайте под катом.\r\n\r\nDisclaimer: Уже несколько раз в моих обсуждениях с коллегами фигурировала статья Брента «New in PHP 7.4». Сначала я хотел сделать перевод, но в процессе понял, что в тексте указаны не все последние обновления и присутствуют некоторые неточности, поэтому вместо перевода появилась эта статья.\r\n\r\nСтрелочные функции (RFC)\r\n\r\nСтрелочные функции позволяют делать более короткую запись анонимных функций:\r\n\r\narray_map(function (User $user) {\r\n    return $user->id;\r\n}, $users)\r\n\r\narray_map(fn(User $user) => $user->id, $users)\r\n\r\nНекоторые особенности принятой реализации стрелочных функций:\r\n\r\nОни могут получить доступ к parent области, таким образом, нет необходимости использовать ключевое слово use.\r\n$this тоже доступна, как и в обычных анонимных функциях.\r\nСтрелочные функции могут содержать только одну строку, которая также является оператором возврата значения.\r\n\r\nПодробнее вы можете прочитать о них в этой статье на Хабре.\r\n\r\nТипизированные свойства (RFC)\r\n \r\nУра! Свойства класса теперь смогут иметь type hint. Это очень долгожданное со времён PHP 7 изменение в направлении более строгой типизации языка. Теперь у нас есть все основные возможности для строгой типизации. Для типизации доступны все типы, за исключением  void и callable.\r\n\r\nclass Bar\r\n{\r\n    public string $name;\r\n    public ?int $amount;\r\n    public Foo $foo;\r\n}\r\n\r\nЕсли хотите чтобы я более подробно рассмотрел новые возможности типизации свойств объектов, отметьтесь в комментариях, и я напишу отдельную статью про них!\r\n\r\nПрисваивающий оператор объединения с null (RFC)\r\n\r\nВместо такой длинной записи:\r\n\r\n$data[\'date\'] = $data[\'date\'] ?? new DateTime();\r\n\r\nТеперь можно будет написать так:\r\n\r\n$data[\'date\'] ??= new DateTime();\r\n\r\nОператор распаковки в массивах (RFC)\r\n\r\nТеперь можно использовать оператор распаковки в массивах:\r\n\r\n$arrayA = [1, 2, 3];\r\n$arrayB = [4, 5];\r\n$result = [0, ...$arrayA, ...$arrayB, 6 ,7];\r\n<i>// [0, 1, 2, 3, 4, 5, 6, 7]</i>\r\n\r\nОбратите внимание, что это работает только с неассоциативными массивами.\r\n\r\nИнтерфейс внешних функций (RFC)\r\n\r\nИнтерфейс внешних функций (FFI) позволяет писать код на C непосредственно в PHP-коде. Это означает, что расширения PHP могут быть написаны на чистом PHP.\r\n\r\nСледует отметить, что это сложная тема. Вам всё ещё нужно знание C, чтобы правильно использовать эти возможности.\r\n\r\nПредзагрузка (RFC)\r\n\r\nПредварительная загрузка — потрясающее дополнение к ядру PHP, которое должно привести к некоторым значительным улучшениям производительности.\r\n\r\nНапример, если вы используете фреймворк, его файлы должны быть загружены и перекомпилированы по каждому запросу. При использовании opcache — при первом участии этих файлов в процессе обработки запроса и далее при каждом успешной проверке на их изменения. Предварительная загрузка позволяет серверу загружать указанные PHP-файлы в память при запуске и иметь их постоянно доступными для всех последующих запросов, без осуществления дополнительных проверок на изменения файлов.\r\n\r\nПовышение производительности происходит «небесплатно» — если предварительно загруженные файлы изменяются, сервер должен быть перезапущен.\r\n\r\nКовариантность/контравариантность в сигнатурах унаследованных методов (RFC)\r\n\r\nВ настоящее время PHP имеет в основном инвариантные типы параметров и инвариантные возвращаемые типы. Данное изменение позволяет изменять тип параметра на один из его супертипов. В свою очередь возвращаемый тип можно заменить на его подтип. Таким образом, данное изменение позволит более строго следовать принципу подстановки Барбары Лисков.\r\n\r\nПример использования ковариантного возвращаемого типа:\r\n\r\ninterface Factory {\r\n    function make(): object;\r\n}\r\nclass UserFactory implements Factory {\r\n    function make(): User;\r\n}\r\n\r\nи контравариантного аргумента:\r\n\r\ninterface Concatable {\r\n    function concat(Iterator $input);\r\n}\r\nclass Collection implements Concatable {\r\n    function concat(iterable $input) {/* . . . */}\r\n}\r\n\r\nПользовательская сериализация объектов (RFC)\r\n\r\nСтановятся доступными два новых магических метода: __serialize и __unserialize. Данный механизм сериализации объединяет универсальность интерфейса Serializable с подходом реализации __sleep/__wakeup методов. Более подробно с их различиями можно ознакомиться в RFC.\r\n\r\nПриоритет операций при конкатенации (RFC)\r\n\r\nЕсли бы вы написали что-нибудь подобное:\r\n\r\necho \"sum: \" . $a + $b;\r\n\r\nСейчас PHP интерпретировал бы это как:\r\n\r\necho (\"sum: \" . $a) + $b;\r\n\r\nPHP 8 будет интерпретировать это иначе:\r\n\r\necho \"sum :\" . ($a + $b);\r\n\r\nPHP 7.4 добавляет предупреждение об устаревании при обнаружении выражения, содержащего \".\" перед \"+ \" или \"-\" и неокружённого при этом скобками.\r\n\r\nПоддержка исключений в __toString (RFC)\r\n\r\nРанее исключения не могли быть выброшены из магического метода  __toString. Обоснованием этого поведения является то, что преобразования объектов к строкам выполняются во многих функциях стандартной библиотеки, и не все они готовы «правильно» обрабатывать исключения. В рамках этого RFC был выполнен всесторонний аудит строковых преобразований в кодовой базе, и данное ограничение теперь можно снять, что и было сделано.\r\n\r\nРефлексия для ссылок (RFC)\r\n\r\nБиблиотеки, такие как symfony/var-dumper, для точного вывода переменных сильно полагаются на ReflectionAPI. Раньше не было надлежащей поддержки рефлексии ссылок, что заставляло эти библиотеки полагаться на хаки для обнаружения ссылок. PHP 7.4 добавляет класс ReflectionReference, который решает эту проблему.\r\n\r\nДобавлен метод mb_str_split (RFC)\r\n\r\nЭта функция обеспечивает ту же функциональность, что и str_split, но для строк, записанных в многобайтовых кодировках.\r\n\r\nВсегда доступное расширение ext-hash (RFC)\r\n\r\nЭто расширение теперь постоянно доступно во всех установках PHP.\r\n\r\nPEAR не включен по умолчанию (EXTERNALS)\r\n\r\nPEAR больше не поддерживается активно, core-команда решила удалить его из установки по умолчанию с PHP 7.4.\r\n\r\nРеестр алгоритмов хэширования паролей (RFC)\r\n\r\nДобавлена новая функция password_algos, которая возвращает список всех зарегистрированных алгоритмов хеширования паролей.\r\n\r\nСлабые ссылки (RFC)\r\n\r\nСлабые ссылки позволяют сохранить ссылку на объект, которая не препятствует уничтожению этого объекта. Например, они полезны для реализации кэш-подобных структур.\r\n\r\nРазделитель числовых литералов (RFC)\r\n\r\nОтсутствие визуальных разделителей в группах цифр увеличивало время чтения и отладки кода, и могло привести к непреднамеренным ошибкам. Теперь добавлена поддержка символа подчёркивания в числовых литералах для визуального разделения групп цифр.\r\n\r\n1_000_000_000  // int\r\n6.674_083e-11; // float\r\n299_792_458;   // decimal\r\n0xCAFE_F00D;   // hexadecimal\r\n0b0101_1111;   // binary\r\n0137_041;      // octal\r\n\r\nКороткие открывающие теги объявлены устаревшими (RFC)\r\n\r\nКороткий открывающий тег <? устарел и будет удалён в PHP 8. Короткий тег <?= (echo) не пострадал.\r\n\r\nЛевоассоциативный тернарный оператор объявлен устаревшим (RFC)\r\n\r\nТернарный оператор имеет некоторые странные причуды в PHP. Этот RFC объявляет устаревшими вложенные тернарные операторы.\r\n\r\n1 ? 2 : 3 ? 4 : 5;   // deprecated\r\n(1 ? 2 : 3) ? 4 : 5; // ok\r\n\r\nВ PHP 8 такая запись приведёт к ошибке уровня компиляции.\r\n\r\nОбратно несовместимые изменения (UPGRADING)\r\n\r\nВот некоторые из самых важных на данный момент обратно несовместимых изменений:\r\n\r\nВызов parent:: в классе не имеющем родителя объявлен устаревшим.\r\nВызов var_dump на экземпляре DateTime или DateTimeImmutable больше не делает доступными свойства объекта.\r\nopenssl_random_pseudo_bytes выдаст исключение в ошибочных ситуациях, вызванных библиотекой OpenSSL. Раньше она возвращала false, что могло привести к генерации пустой строки.\r\nПопытка сериализировать PDO или экземпляр PDOStatement генерирует Exception вместо PDOException.\r\nВызов get_object_vars() на экземпляре ArrayObject возвратит свойства самого ArrayObject, а не значения обёрнутого массива. Чтобы как раньше получить значения обернутого массива — приведите ArrayObject к типу array.', '2019-06-04 18:00:00', '2019-06-05 09:25:42'),
(5, 'Визуализация сортировки обменами', 'В данной статье рассматриваются различные варианты сортировки обменами, а также даётся описание простого графического приложения (processing.js) с примерами сортировок. \r\n\r\nПеред прочтением рекомендую ознакомиться со статьями: \r\n\r\n→ Сортировка обменами\r\n→ Пузырьковая сортировка и все-все-все\r\n→ Глупая сортировка и некоторые другие, поумнее\r\n\r\nПростейший вариант: перебирать массив от первого элеменат к последнему, меняя местами (если потребуется) соседние элементы. \r\n\r\n→ Проверить можно здесь\r\n\r\nДля того, чтобы передвинуть ползунок, надо нажать на серую кнопку в левом нижнем углу.\r\nПри нажатии на кнопку проверяем, не достигли ли мы конца массива (тогда прыгаем в начало), дальше сравниваем (меняем местами) соседние элементы:\r\n\r\nКод кнопки\r\nProcessing.js использует структуры данных Java, потом код транслируется в javascript, поэтому\r\nобъявление массива экземпляров класса Module, отвечающего за отрисовку элементов и инициализация экземпляров происходит так:\r\n\r\nКод\r\nОсновная функция отрисовки void draw() представляет собой бесконечный цикл, в котором перебираются экземпляры класса:\r\n\r\nПеребор экземпляров класса\r\nМожно уменьшить количество переборов, если не перебирать уже отсортированные элементы. Для этого добавим в конец массива limiter (ограничитель), который будет сдвигаться к началу массива после каждого перебора.\r\n\r\n→ Проверить можно здесь\r\n\r\nЕсли добавить ограничитель в начало массива, получим шейкерную сортировку.\r\n\r\nЕще об одном способе уменьшить количество переборов можно прочитать в статье Cортировка пузырьком (Википедия). Если при проходе массива мы ни разу не поменяли соседние элементы местами, значит массив отсортирован и цикл можно завершать.\r\n\r\nДобавим флаг flag, который поднимается, когда мы встречаем пару элементов, которые нужно поменять местами. Если флаг поднят, перебираем массив повторно. Если нет, заканчиваем цикл. Состояние флага выводится в консоль.\r\n\r\nПроверка соседних элементов\r\n→ Проверить можно здесь\r\n\r\nИзменив логику работы ограничителя, получим сортировку расчёской/гребёнкой. Сравниваем/меняем элементы. Сдвигаем ограничитель влево и сохраняем его индекс в переменой limiterStore.\r\n\r\nCдвигаем ползунок с ограничителем в конец массива, сравнивая/меняя элементы.\r\n\r\nКод\r\nif(limiter!=moduleSize)   {   //пока не достигли конца массива\r\n   limiter++;\r\n   incPaddle++;\r\n  }\r\n\r\n\r\nПри достижении ограничителем конца массива, ставим ползунок в начало массива, а ограничитель приравниваем к limiterStore-1:\r\n\r\nКод\r\n  if(limiter==moduleSize)   {\r\n    limiter = limiterStore-1;\r\n    limiterStore = limiter;\r\n    incPaddle=1;\r\n   }', '2019-06-04 18:00:00', '2019-06-05 09:26:45');
INSERT INTO `posts` (`id`, `title`, `body`, `created_at`, `updated_at`) VALUES
(7, 'Указатели в Python: в чём суть?', 'Eсли вы когда-нибудь работали с такими низкоуровневыми языками, как С или С++, то наверняка слышали про указатели. Они позволяют сильно повышать эффективность разных кусков кода. Но также они могут запутывать новичков — и даже опытных разработчиков — и приводить к багам управления памятью. А есть ли указатели в Python, можно их как-то эмулировать?\r\n\r\nУказатели широко применяются в С и С++. По сути, это переменные, которые содержат адреса памяти, по которым находятся другие переменные. Чтобы освежить знания об указателях, почитайте этот обзор.\r\n\r\nБлагодаря этой статье вы лучше поймёте модель объектов в Python и узнаете, почему в этом языке на самом деле не существуют указатели. На случай, если вам понадобится сымитировать поведение указателей, вы научитесь эмулировать их без сопутствующего кошмара управления памятью.\r\n\r\nС помощью этой статьи вы:\r\n\r\nУзнаете, почему в Python нет указателей.\r\nУзнаете разницу между переменными C и именами в Python.\r\nНаучитесь эмулировать указатели в Python.\r\nС помощью ctypes поэкспериментируете с настоящими указателями.\r\n\r\nПримечание: Здесь термин «Python» применяется к реализации Python на C, которая известна под названием CPython. Все обсуждения устройства языка справедливы для CPython 3.7, но могут не соответствовать последующим итерациям.\r\n\r\nПочему в Python нет указателей?\r\n\r\nНе знаю. Могут ли указатели существовать в Python нативно? Вероятно, но судя по всему, указатели противоречат понятию Zen of Python, потому что провоцируют неявные изменения вместо явных. Нередко указатели довольно сложны, особенно для новичков. Более того, они подталкивают вас к неудачным решениям или к тому, чтобы сделать что-нибудь действительно опасное, вроде чтения из области памяти, откуда вам не следовало считывать.\r\n\r\nPython старается абстрагировать от пользователя подробности реализации, например адреса памяти. Часто в этом языке упор делается на удобство использования, а не на скорость. Поэтому указатели в Python не имеют особого смысла. Но не переживайте, по умолчанию язык предоставляет вам некоторые преимущества использования указателей.\r\n\r\nЧтобы разобраться с указателями в Python, давайте кратко пройдёмся по особенностями реализации языка. В частности, вам нужно понять:\r\n\r\nЧто такое изменяемые и неизменяемые объекты.\r\nКак устроены переменные/имена в Python.\r\n\r\nДержитесь за свои адреса памяти, поехали!\r\n\r\nОбъекты в Python\r\n\r\nВсё в Python является объектами. Например, откройте REPL и посмотрите, как используется isinstance():\r\n\r\n>>> isinstance(1, object)\r\nTrue\r\n>>> isinstance(list(), object)\r\nTrue\r\n>>> isinstance(True, object)\r\nTrue\r\n>>> def foo():\r\n...    pass\r\n...\r\n>>> isinstance(foo, object)\r\nTrue\r\n\r\nЭтот код демонстрирует, что всё в Python — на самом деле объекты. Каждый объект содержит как минимум три вида данных:\r\n\r\nСчётчик ссылок.\r\nТип.\r\nЗначение.\r\n\r\nСчётчик ссылок используется для управления памятью. Подробно об этом управлении написано в Memory Management in Python. Тип используется на уровне CPython для обеспечения типобезопасности в ходе исполнения (runtime). А значение — это фактическое значение, ассоциированное с объектом.\r\n\r\nНо не все объекты одинаковы. Есть одно важное отличие: объекты бывают изменяемые и неизменяемые. Понимание этого различия между типами объектов поможет вам лучше осознать первый слой луковицы, которая называется «указатели в Python».\r\n\r\nИзменяемые и неизменяемые объекты\r\n\r\nВ Python есть два типа объектов:\r\n\r\nНеизменяемые объекты (не могут быть изменены);\r\nИзменяемые объекты (могут быть изменены).\r\n\r\nОсознание этой разницы — первый ключ к путешествию по миру указателей в Python. Вот характеристика неизменяемости некоторых популярных типов:\r\n\r\nТип\r\nНеизменяемый?\r\nint\r\nДа\r\nfloat\r\nДа\r\nbool\r\nДа\r\ncomplex\r\nДа\r\ntuple\r\nДа\r\nfrozenset\r\nДа\r\nstr\r\nДа\r\nlist\r\nНет\r\nset\r\nНет\r\ndict\r\nНет\r\n\r\nКак видите, многие из часто используемых примитивных типов являются неизменяемыми. Проверить это можно, написав кое-какой код на Python. Вам понадобится два инструмента из стандартной библиотеки:\r\n\r\nid() возвращает адрес памяти объекта;\r\nis возвращает True, если и только если два объекта имеют одинаковый адрес памяти.\r\n\r\nМожете прогнать этот код в REPL-окружении:\r\n\r\n>>> x = 5\r\n>>> id(x)\r\n94529957049376\r\n\r\nЗдесь мы присвоили переменной x значение 5. Если вы попробуете изменить значение с помощью сложения, то получите новый объект:\r\n\r\n>>> x += 1\r\n>>> x\r\n6\r\n>>> id(x)\r\n94529957049408\r\n\r\nХотя может показаться, что этот код просто меняет значение x, но на самом деле вы получаете в качестве ответа новый объект.\r\n\r\nТип str тоже неизменяем:\r\n\r\n>>> s = \"real_python\"\r\n>>> id(s)\r\n140637819584048\r\n>>> s += \"_rocks\"\r\n>>> s\r\n\'real_python_rocks\'\r\n>>> id(s)\r\n140637819609424\r\n\r\nИ в этом случае s после операции += получает другой адрес памяти.\r\n\r\nБонус: Оператор += преобразовывается в различные вызовы методов.\r\n\r\nДля некоторых объектов, таких как список, += преобразует в __iadd__() (локальное добавление). Оно изменит себя и вернёт тот же ID. Однако у str и int нет этих методов, и в результате будет вызываться __add__() вместо __iadd__().\r\n\r\nПодробнее об этом рассказывается в документации по моделям данных Python.\r\n\r\nПри попытке напрямую изменить строковое значение s мы получим ошибку:\r\n\r\n>>> s[0] = \"R\"\r\n\r\nОбратная трассировка (последними отображаются самые свежие вызовы):\r\n\r\n  File \"<stdin>\", line 1, in <mоdule>\r\nTypeError: \'str\' object does not support item assignment\r\n\r\nПриведённый выше код сбоит и Python сообщает, что str не поддерживает это изменение, что соответствует определению неизменяемости типа str.\r\n\r\nСравните с изменяемым объектом, например, со списком:\r\n\r\n>>> my_list = [1, 2, 3]\r\n>>> id(my_list)\r\n140637819575368\r\n>>> my_list.append(4)\r\n>>> my_list\r\n[1, 2, 3, 4]\r\n>>> id(my_list)\r\n140637819575368\r\n\r\nЭтот код демонстрирует основное различие между двумя типами объектов. Изначально у my_list есть ID. Даже после добавления к списку 4, my_list всё ещё имеет тот же ID. Причина в том, что тип list является изменяемым.\r\n\r\nВот ещё одна демонстрация изменяемости списка с помощью присваивания:\r\n\r\n>>> my_list[0] = 0\r\n>>> my_list\r\n[0, 2, 3, 4]\r\n>>> id(my_list)\r\n140637819575368\r\n\r\nВ этом коде мы изменили my_list и задали ему в качестве первого элемента 0. Однако список сохранил тот же ID после этой операции. Следующим шагом на нашем пути к познанию Python будет исследование его экосистемы.\r\n\r\nРазбираемся с переменными\r\n\r\nПеременные в Python в корне отличаются от переменных в C и C++. По сути, их просто нет в Python. Вместо переменных здесь имена.\r\n\r\nЭто может звучать педантично, и по большей части так оно и есть. Чаще всего можно воспринимать имена в Python в качестве переменных, но необходимо понимать разницу. Это особенно важно, когда изучаешь такую непростую тему, как указатели.\r\n\r\nЧтобы вам было проще разобраться, давайте посмотрим, как работают переменные в С, что они представляют, а затем сравним с работой имён в Python.\r\n\r\nПеременные в C\r\n\r\nВозьмём код, который определяет переменную x:\r\n\r\nint x = 2337;\r\n\r\nИсполнение это короткой строки проходит через несколько различных этапов:\r\n\r\nВыделение достаточного количества памяти для числа.\r\nПрисвоение этому месту в памяти значения 2337.\r\nОтображение, что x указывает на это значение.\r\n\r\nУпрощённо память может выглядеть так:\r\n\r\n\r\n\r\nЗдесь переменная x имеет фальшивый адрес 0x7f1 и значение 2337. Если позднее вам захочется изменить значение x, можете сделать так:\r\n\r\nx = 2338;\r\n\r\nЭтот код присваивает переменной x новое значение 2338, тем самым перезаписывая предыдущее значение. Это означает, что переменная x изменяема. Обновлённая схема памяти для нового значения:\r\n\r\n\r\n\r\nОбратите внимание, что расположение x не поменялось, только само значение. Это важно. Нам это говорит о том, что x — это место в памяти, а не просто имя.\r\n\r\nМожно также рассматривать этот вопрос в рамках концепции владения. С одной стороны, x владеет местом в памяти. Во-первых, x — это пустая коробка, которая может содержать лишь одно число (integer), в котором могут храниться целочисленные значения.\r\n\r\nКогда вы присваиваете x какое-то значение, вы тем самым помещаете значение в коробку, принадлежащую x. Если вы хотите представить новую переменную y, то можете добавить такую строку:\r\n\r\nint y = x;\r\n\r\nЭтот код создаёт новую коробку под названием y и копирует в неё значение из x. Теперь схема памяти выглядит так:\r\n\r\n\r\n\r\nОбратите внимание на новое местоположение y — 0x7f5. Хотя в y и было скопировано значение x, однако переменная y владеет новым адресом в памяти. Следовательно, вы можете перезаписывать значение y, не влияя на x:\r\n\r\ny = 2339;\r\n\r\nТеперь схема памяти выглядит так:\r\n\r\n\r\n\r\nПовторюсь: вы изменили значение y, но не местоположение. Кроме того, вы никак не повлияли на исходную переменную x. \r\n\r\nС именами в Python совершенно иная ситуация.\r\n\r\nИмена в Python\r\n\r\nВ Python нет переменных, вместо них имена. Вы можете на своё усмотрение использовать термин «переменные», однако важно знать разницу между переменными и именами.\r\n\r\nДавайте возьмём эквивалентный код из вышеприведённого примера на С и напишем его на Python:\r\n\r\n>>> x = 2337\r\n\r\nКак и в C, в ходе исполнения этого код проходит несколько отдельных этапов:\r\n\r\nСоздаётся PyObject.\r\nЧислу для PyObject’а присваивается typecode.\r\n2337 присваивается значение для PyObject’а.\r\nСоздаётся имя x.\r\nx указывает на новый PyObject.\r\nСчётчик ссылок PyObject’а увеличивается на 1.\r\n\r\nПримечание: PyObject — не то же самое, что объект в Python, эта сущность характерна для CPython и представляет базовую структуру всех объектов Python.\r\n\r\nPyObject определяется как C-структура, так что если вы удивляетесь, почему нельзя напрямую вызвать typecode или счётчик ссылок, то причина в том, что у вас нет прямого доступа к структурам. Вызовы методов вроде sys.getrefcount() могут помочь получить какие-то внутренние вещи.\r\n\r\nЕсли говорить о памяти, то это может выглядеть таким образом:\r\n\r\n\r\n\r\nЗдесь схема памяти сильно отличается от схемы в С, показанной выше. Вместо того, чтобы x владел блоком памяти, в котором хранится значение 2337, свежесозданный объект Python владеет памятью, в которой живёт 2337. Python-имя x не владеет напрямую каким-либо адресом в памяти, как С-переменная владеет статической ячейкой.\r\n\r\nЕсли хотите присвоить x новое значение, попробуйте такой код:\r\n\r\n>>> x = 2338\r\n\r\nПоведение системы будет отличаться от того, что происходит в С, но будет не слишком сильно отличаться от исходной привязки (bind) в Python.\r\n\r\nВ этом коде:\r\n\r\nСоздаётся новый PyObject.\r\nЧислу для PyObject’а присваивается typecode.\r\n2 присваивается значение для PyObject’а.\r\nx указывает на новый PyObject.\r\nСчётчик ссылок нового PyObject увеличивается на 1.\r\nСчётчик ссылок старого PyObject уменьшается на 1.\r\n\r\nТеперь схема памяти выглядит так:\r\n\r\n\r\n\r\nЭта иллюстрация демонстрирует, что x указывает на ссылку на объект и не владеет областью памяти, как раньше. Также вы видите, что команда x = 2338 является не присваиванием, а, скорее, привязкой (binding) имени x к ссылке.\r\n\r\nКроме того, предыдущий объект (содержавший значение 2337) теперь находится в памяти со счётчиком ссылок, равным 0, и будет убран сборщиком мусора.\r\n\r\nВы можете ввести новое имя y, как в примере на С:\r\n\r\n>>> y = x\r\n\r\nВ памяти появится новое имя, но не обязательно новый объект:\r\n\r\n\r\n\r\nТеперь вы видите, что новый Python-объект не создан, создано только новое имя, которое указывает на тот же объект. Кроме того, счётчик ссылок объекта увеличился на 1. Можете проверить эквивалентность идентичности объектов, чтобы подтвердить их одинаковость:\r\n\r\n>>> y is x\r\nTrue\r\n\r\nЭтот код показывает, что x и y являются одним объектом. Но не ошибитесь: y всё ещё является неизменяемым. Например, вы можете выполнить с y операцию сложения:\r\n\r\n>>> y += 1\r\n>>> y is x\r\nFalse\r\n\r\nПосле вызова сложения, вам вернётся новый Python-объект. Теперь память выглядит так:\r\n\r\n\r\n\r\nБыл создан новый объект, и y теперь указывает на него. Любопытно, что точно такое же конечное состояние мы получили бы, если напрямую привязали y к 2339:\r\n\r\n>>> y = 2339\r\n\r\nПосле этого выражения мы получим такое конечное состояние памяти, как и при операции сложения. Напомню, что в Python вы не присваиваете переменные, а привязываете имена к ссылкам.\r\n\r\nОб интернированных (intern) объектах в Python\r\n\r\nТеперь вы понимаете, как создаются новые объекты в Python и как к ним привязываются имена. Пришло время поговорить об интернированных (interned) объектах.\r\n\r\nУ нас есть такой Python-код:\r\n\r\n>>> x = 1000\r\n>>> y = 1000\r\n>>> x is y\r\nTrue\r\n\r\nКак и раньше, x и y являются именами, указывающими на один и тот же Python-объект. Но это объект, содержащий значение 1000, не может всегда иметь одинаковый адрес памяти. Например, если вы сложили два числа и получили 1000, то получите другой адрес:\r\n\r\n>>> x = 1000\r\n>>> y = 499 + 501\r\n>>> x is y\r\nFalse\r\n\r\nНа этот раз строка x is y возвращает False. Если вас это смутило, не беспокойтесь. Вот что происходит при исполнении этого кода:\r\n\r\nСоздаётся Python-объект (1000).\r\nЕму присваивается имя x.\r\nСоздаётся Python-объект (499).\r\nСоздаётся Python-объект (501).\r\nЭти два объекта складываются.\r\nСоздаётся новый Python-объект (1000).\r\nЕму присваивается имя y.\r\n\r\nТехнические пояснения: описанные шаги имеют место только в том случае, когда этот код исполняется внутри REPL. Если вы возьмёте приведённый пример, вставите в файл и запустите его, то строка x is y вернёт True.\r\n\r\nПричина в сообразительности компилятора CPython, который старается выполнить peephole-оптимизации, помогающие по мере возможности экономить шаги исполнения кода. Подробности вы можете найти в исходном коде peephole-оптимизатора CPython.\r\n\r\nНо разве это не расточительно? Ну да, но эту цену вы платите за все замечательные преимущества Python. Вам не нужно думать об удалении подобных промежуточных объектов, и даже не нужно знать об их существовании! Прикол в том, что эти операции выполняются относительно быстро, и вы бы о них не узнали до этого момента.\r\n\r\nСоздатели Python мудро подметили эти накладные расходы и решили сделать несколько оптимизаций. Их результатом является поведение, которое может удивить новичков:\r\n\r\n>>> x = 20\r\n>>> y = 19 + 1\r\n>>> x is y\r\nTrue\r\n\r\nВ этом примере почти такой же код, как и выше, за исключением того, что мы получаем True. Всё дело в интернированных (interned) объектах. Python предварительно создаёт в памяти определённое подмножество объектов и хранит их в глобальном пространстве имён для повседневного использования.\r\n\r\nКакие объекты зависят от реализации Python? В CPython 3.7 интернированными являются:\r\n\r\nЦелые числа в диапазоне от -5 до 256.\r\nСтроки, содержащие только ASCII-буквы, цифры или знаки подчёркивания.\r\n\r\nТак сделано потому, что эти переменные очень часто используются во многих программах. Интернируя, Python предотвращает выделение памяти для постоянно используемых объектов.\r\n\r\nСтроки размером меньше 20 символов и содержащие ASCII-буквы, цифры или знаки подчёркивания будут интернированы, поскольку предполагается, что они будут применяться в качестве идентификаторов:\r\n\r\n>>> s1 = \"realpython\"\r\n>>> id(s1)\r\n140696485006960\r\n>>> s2 = \"realpython\"\r\n>>> id(s2)\r\n140696485006960\r\n>>> s1 is s2\r\nTrue\r\n\r\nЗдесь s1 и s2 указывают на один и тот же адрес в памяти. Если бы мы вставили не ASCII-букву, цифру или знак подчёркивания, то получили бы другой результат:\r\n\r\n>>> s1 = \"Real Python!\"\r\n>>> s2 = \"Real Python!\"\r\n>>> s1 is s2\r\nFalse\r\n\r\nВ этом примере использован восклицательный знак, поэтому строки не интернированы и являются разными объектами в памяти.\r\n\r\nБонус: Если хотите, чтобы эти объекты ссылались на один и тот же интернированный объект, то можете воспользоваться sys.intern(). Один из способов применения этой функции описан в документации:\r\n\r\nИнтернирование строк полезно для небольшого повышения производительности при поиске по словарю: если ключи в словаре и искомый ключ интернированы, то сравнение ключей (после хэширования) может выполняться с помощью сравнения указателей, а не строк. (Источник)\r\n\r\nИнтернированные объекты часто путают программистов. Просто запомните, что если начнёте сомневаться, то всегда можете воспользоваться id() и is для определения эквивалентности объектов.\r\n\r\nЭмулирование указателей в Python\r\n\r\nТот факт, что указатели в Python отсутствуют нативно, не означает, что вы не можете воспользоваться преимуществами применения указателей. На самом деле есть несколько способов эмулирования указателей в Python. Здесь мы рассмотрим два из них:\r\n\r\nПрименение в качестве указателей изменяемых типов.\r\nПрименение специально подготовленных Python-объектов.\r\n\r\nПрименение в качестве указателей изменяемых типов\r\n\r\nВы уже знаете, что такое изменяемые типы. Именно благодаря их изменяемости мы можем эмулировать поведение указателей. Допустим, нужно реплицировать этот код:\r\n\r\nvoid add_one(int *x) {\r\n    *x += 1;\r\n}\r\n\r\nЭтот код берёт указатель на число (*x) и инкрементирует значение на 1. Вот основная функция для исполнения кода:\r\n\r\n#include <stdiо.h>\r\n\r\nint main(void) {\r\n    int y = 2337;\r\n    printf(\"y = %d\\n\", y);\r\n    add_one(&y);\r\n    printf(\"y = %d\\n\", y);\r\n    return 0;\r\n}\r\n\r\nВ приведённом фрагменте мы присвоили y значение 2337, вывели на экран текущее значение, увеличили его на 1, а затем вывели новое значение. На экране появляется:\r\n\r\ny = 2337\r\ny = 2338\r\n\r\nОдин из способов репликации этого поведения в Python — использовать изменяемый тип. Например, применить список и изменить первый элемент:\r\n\r\n>>> def add_one(x):\r\n...    x[0] += 1\r\n...\r\n>>> y = [2337]\r\n>>> add_one(y)\r\n>>> y[0]\r\n2338\r\n\r\nЗдесь add_one(x) обращается к первому элементу и увеличивает его значение на 1. Применение списка означает, что в результате мы получим изменённое значение. Так значит в Python существуют указатели? Нет. Описанное поведение стало возможным потому, что список — это изменяемый тип. Если вы попытаетесь использовать кортеж, то получите ошибку:\r\n\r\n>>> z = (2337,)\r\n>>> add_one(z)\r\n\r\nОбратная трассировка (последними идут самые свежие вызовы):\r\n\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"<stdin>\", line 2, in add_one\r\nTypeError: \'tuple\' object does not support item assignment\r\n\r\nЭтот код демонстрирует неизменяемость кортежа, поэтому он не поддерживает присваивание элементов. \r\n\r\nlist не единственный изменяемый тип, указатели части эмулируются и с помощью dict.\r\n\r\nДопустим, у вас есть приложение, которое должно отслеживать возникновение интересных событий. Это можно сделать с помощью создания словаря и использования одного из его элементов в качестве счётчика:\r\n\r\n>>> counters = {\"func_calls\": 0}\r\n>>> def bar():\r\n...    counters[\"func_calls\"] += 1\r\n...\r\n>>> def foo():\r\n...    counters[\"func_calls\"] += 1\r\n...    bar()\r\n...\r\n>>> foo()\r\n>>> counters[\"func_calls\"]\r\n2\r\n\r\nВ этом примере словарь использует счётчики для отслеживания количества вызовов функции. После вызова foo() счётчик увеличился на 2, как и ожидалось. И всё благодаря изменяемости dict.\r\n\r\nНе забывайте, это лишь эмуляция поведения указателя, оно никак не связано с настоящими указателями в C и C++. Можно сказать, эти операции обходятся дороже, чем если бы они выполнялись в C или C++.\r\n\r\nИспользование объектов Python\r\n\r\ndict — прекрасный способ эмулирования указателей в Python, но иногда бывает утомительно помнить, какое имя ключа вы использовали. Особенно, если вы применяете словарь в разных частях приложения. Здесь может помочь настраиваемый класс Python.\r\n\r\nДопустим, вам нужно отслеживать метрики в приложении. Отличный способ абстрагироваться от раздражающих подробностей — это создать класс:\r\n\r\nclass Metrics(object):\r\n    def __init__(self):\r\n        self._metrics = {\r\n            \"func_calls\": 0,\r\n            \"cat_pictures_served\": 0,\r\n        }\r\n\r\nВ этом коде определён класс Metrics. Он всё ещё использует словарь для хранения актуальных данных, которые лежат в переменной члена _metrics. Это даст вам требуемую изменяемость. Теперь нужно лишь получить доступ к этим значениям. Можно сделать это с помощью свойств:\r\n\r\nclass Metrics(object):\r\n    # ...\r\n\r\n    @property\r\n    def func_calls(self):\r\n        return self._metrics[\"func_calls\"]\r\n\r\n    @property\r\n    def cat_pictures_served(self):\r\n        return self._metrics[\"cat_pictures_served\"]\r\n\r\nЗдесь мы используем @property. Если вы не знакомы с декораторами, то почитайте статью Primer on Python Decorators. В данном случае декоратор @property позволяет обратиться к func_calls и cat_pictures_served, как если бы они были атрибутами:\r\n\r\n>>> metrics = Metrics()\r\n>>> metrics.func_calls\r\n0\r\n>>> metrics.cat_pictures_served\r\n0\r\n\r\nТо, что вы можете обратиться к этим именам как к атрибутам, означает, что вы абстрагированы от факта, что эти значения хранятся в словаре. К тому же вы делаете имена атрибутов более явными. Конечно, у вас должна быть возможность увеличивать значения:\r\n\r\nclass Metrics(object):\r\n    # ...\r\n\r\n    def inc_func_calls(self):\r\n        self._metrics[\"func_calls\"] += 1\r\n\r\n    def inc_cat_pics(self):\r\n        self._metrics[\"cat_pictures_served\"] += 1\r\n\r\nМы ввели два новых метода:\r\n\r\ninc_func_calls()\r\ninc_cat_pics()\r\n\r\nОни меняют значения в словаре metrics. Теперь у вас есть класс, который можно изменить так же, как и указатель:\r\n\r\n>>> metrics = Metrics()\r\n>>> metrics.inc_func_calls()\r\n>>> metrics.inc_func_calls()\r\n>>> metrics.func_calls\r\n2\r\n\r\nВы можете обращаться к func_calls и вызывать inc_func_calls() в разных частях приложений и эмулировать указатели в Python. Это полезно в ситуациях, когда у вас есть что-то вроде metrics, что нужно часто использовать и обновлять в разных частях приложений.\r\n\r\nПримечание: В данном случае, явное создание inc_func_calls() и inc_cat_pics() вместо использования @property.setter не даёт пользователям задавать эти значения произвольному int, или неправильное значение вроде словаря.\r\n\r\nВот полный исходный код класса Metrics:\r\n\r\nclass Metrics(object):\r\n    def __init__(self):\r\n        self._metrics = {\r\n            \"func_calls\": 0,\r\n            \"cat_pictures_served\": 0,\r\n        }\r\n\r\n    @property\r\n    def func_calls(self):\r\n        return self._metrics[\"func_calls\"]\r\n\r\n    @property\r\n    def cat_pictures_served(self):\r\n        return self._metrics[\"cat_pictures_served\"]\r\n\r\n    def inc_func_calls(self):\r\n        self._metrics[\"func_calls\"] += 1\r\n\r\n    def inc_cat_pics(self):\r\n        self._metrics[\"cat_pictures_served\"] += 1\r\n\r\nРеальные указатели с помощью ctypes\r\n\r\nМожет быть, всё-таки есть указатели в Python, особенно в CPython? С помощью встроенного модуля ctypes можно создать настоящие указатели, как в C. Если вы не знакомы с ctypes, можете почитать статью Extending Python With C Libraries and the «ctypes» Module.\r\n\r\nВам это может понадобиться в тех случаях, когда нужно вызвать библиотеку С, которой необходимы указатели. Вернёмся к упомянутой выше С-функции add_one():\r\n\r\nvoid add_one(int *x) {\r\n    *x += 1;\r\n}\r\n\r\nНапомню, что этот код увеличивает значение x на 1. Чтобы им воспользоваться, сначала скомпилируем код в общий (shared) объект. Будем считать, что наш файл хранится в add.c, сделать это можно с помощью gcc:\r\n\r\n$ gcc -c -Wall -Werror -fpic add.c\r\n$ gcc -shared -o libadd1.so add.o\r\n\r\nПервая команда компилирует исходный файл C в объект add.o. Вторая команда берёт этот несвязанный объект и создаёт общий объект libadd1.so.\r\n\r\nlibadd1.so должен лежать в вашей текущей директории. Можете с помощью ctypes загрузить его в Python:\r\n\r\n>>> import ctypes\r\n>>> add_lib = ctypes.CDLL(\"./libadd1.so\")\r\n>>> add_lib.add_one\r\n<_FuncPtr object at 0x7f9f3b8852a0>\r\n\r\nКод ctypes.CDLL возвращает объект, который представляет общий объект libadd1. Поскольку в нём вы определили add_one(), вы можете обращаться к этой функции, как если бы это был любой другой Python-объект. Но прежде чем вызывать функцию, нужно определить её сигнатуру. Так Python будет знать, что вы передаёте функции правильный тип.\r\n\r\nВ нашем случае сигнатурой функции является указатель на число, ctypes позволит задать это с помощью такого кода:\r\n\r\n>>> add_one = add_lib.add_one\r\n>>> add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]\r\n\r\nЗдесь мы задаём сигнатуру функции, чтобы удовлетворить ожиданиям C. Теперь, если попробуем вызвать этот код с неправильным типом, то вместо непредсказуемого поведения получим красивое предупреждение:\r\n\r\n>>> add_one(1)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nctypes.ArgumentError: argument 1: <class \'TypeError\'>: \\\r\nexpected LP_c_int instance instead of int\r\n\r\nPython бросает ошибку и объясняет, что add_one() хочет получить указатель, а не просто целое число. К счастью, в ctypes есть способ передавать указатели таким функциям. Сначала объявим целое число в стиле С:\r\n\r\n>>> x = ctypes.c_int()\r\n>>> x\r\nc_int(0)\r\n\r\nЗдесь мы создали целое число x со значением 0. ctypes предоставляет удобную функцию byref(), которая позволяет передавать переменную по ссылке.\r\n\r\nПримечание: Словосочетание по ссылке является антонимом передаче переменной по значению.\r\n\r\nПри передаче по ссылке вы передаёте ссылку на исходную переменную, поэтому изменения будут отражены и на ней. При передаче по значению вы получаете копию исходной переменной, и изменения эту исходную переменную уже не затрагивают.\r\n\r\nДля вызова add_one() можете использовать этот код:\r\n\r\n>>> add_one(ctypes.byref(x))\r\n998793640\r\n>>> x\r\nc_int(1)\r\n\r\nОтлично! Ваше число увеличилось на 1. Поздравляю, вы успешно использовали в Python настоящие указатели.\r\n\r\nЗаключение\r\n\r\nТеперь вы лучше понимаете взаимосвязь между объектами Python и указателями. Хотя некоторые уточнения касательно имён и переменных выглядят проявлениями педантизма, однако понимание сути эти ключевых терминов улучшает ваше понимание механизма обработки переменных в Python.\r\n\r\nТакже мы узнали некоторые способы эмулирования указателей в Python:\r\n\r\nИспользование изменяемых объектов в качестве указателей с низкими накладными расходами.\r\nСоздание настраиваемых Python-объектов для простоты использования.\r\nРазлочивание настоящих указателей с помощью модуля ctypes.\r\n\r\nЭти методы позволяют эмулировать указатели в Python без необходимости жертвовать предоставляемой языком безопасностью памяти.', '2019-06-04 18:00:00', '2019-06-05 09:31:04'),
(9, 'BotAuth — вход и регистрация при помощи ботов', 'BotAuth — пакет, который позволяет реализовать вход при помощи бота Вконтакте, FaceBook, Telegram.\r\n\r\nОсновная задача BotAuth, упростить посетителям Веб сайтов/PWA вход через социальные сети. \r\n\r\nПока соц. сети не реализуют обратную связь нативных мобильных приложений с веб сайтом, разработчикам приходится отправлять пользователя в браузер, где снова нужно вводить логин и пароль.\r\n\r\nИспользуя ботов, можно получить обратную связь (callback) из нативного приложения, тем самым не заставлять вводить логин и пароль соц. сети в браузере.\r\n\r\nDemo — https://laravel.zetrider.ru/botauth\r\nGitHub — https://github.com/zetrider/BotAuth\r\n\r\nСсылки вида: \r\n\r\nhttps://vk.me/ https://t.me/ https://m.me/\r\n\r\nоткроют мобильное приложение для начала диалога с ботом. Посетителю не придется повторно вводить логин и пароль в браузере.\r\n\r\nВы можете подключить ботов:\r\n\r\nВконтакте\r\nTelegram\r\nFaceBook\r\nВаш собственный провайдер (пример ниже)\r\n\r\nУстановка\r\nПодключение ботов:\r\n\r\nВконтакте\r\nTelegram\r\nFacebook\r\nВажно:\r\n\r\nСайт должен работать по https\r\nFacebook бот возвращает PSID, который не соответствует публичному ID пользователя.\r\nПо умолчанию контроллер бота работает с моделью \\App\\User. Если у вас другой случай, просто создайте свой контроллер и модель на основе примеров из репозитория. Модель, Контроллер\r\n\r\nКак добавить свой провайдер:\r\n\r\nСоздайте свой класс, который наследует абстрактный класс \r\n\r\nZetRider\\BotAuth\\AbstractProvider\r\n\r\nПример example/ExampleProvider.php\r\n\r\nДобавьте в сервис провайдер, например AppServiceProvider в методе boot\r\n\r\n\r\n// Register example proider\r\nBotAuth::extend(\'example\', function() {\r\n    return new \\Path\\To\\Your\\Class\\ExampleProvider();\r\n});\r\n\r\nПровайдер будет обрабатывать запросы в callback по адресу \r\n\r\nhttps://.../botauth/callback/example\r\n\r\nСобытия\r\n\r\nСобытие при успешной обработке нового сообщения от бота\r\n\r\n\r\n// Catch bot callback\r\n\\Event::listen(\\ZetRider\\BotAuth\\Events\\MessageNewEvent::class, function($event)\r\n{\r\n    $provider = $event->provider; // ZetRider\\BotAuth\\AbstractProvider\r\n\r\n    $slug = $provider->getProviderSlug();\r\n    $data = $provider->getCallbackResponse();\r\n    $user = $provider->getUser();\r\n    $text = $provider->getText();\r\n\r\n    // You can send a message\r\n    // $provider->sendMessage(__(\'Back to web site\'));\r\n});', '2019-06-12 18:00:00', '2019-06-13 05:38:36'),
(10, 'Новые языки программирования незаметно убивают нашу связь с реальностью', 'Однажды настанет день, когда команды в программировании будут выглядеть вроде «эй, компьютер, сделай-ка мне вот эту хреновину». \r\n\r\nЧто там будет под капотом, ни одна живая душа уже не поймет. Команда «хреновина» интерпретируется в абзац с описанием, который интерпретируется в ключевые слова, который интерпретируется в набор векторных обозначений, который интерпретируется в какой-нибудь С, который скомпилируется в… \r\n\r\nи где-то там внизу превратится в электрические импульсы на железяках.\r\n\r\nПрограммистами станут лощеные гуманитарии с «высокими вербальными способностями, коммуникативными навыками и умением быть няшей в команде». Слава богу до этого дня, как до Аляски на упряжке, но каждый раз изобретая очередной Kotlin, мы этот день приближаем. \r\n\r\nПросто я задумался — а не стали ли наши ЯПы уже чем-то таким? Чуть более умным эквивалентом фразы «компьютер, сделай хреновину». Кучей формализованных протоколов для электричества, про которое мы уже забыть забыли. Штукой, которая все сильнее рвет нашу связь с механической реальностью. \r\n\r\nЯ часто слышу фразу: «Фил, отступись, хватит думать обо всякой чепухе». Но блин, будь проклят тот день, когда на Хабре напишут «хватит думать».\r\n\r\n\r\nУ меня на работе много небольших проектов, и мы используем разные стеки — .net, React.ts, c++, Java. В чем ты хоть немного прошарен, то на тебя и повесят. Я пришел как дотнетчик, но таски на доске есть на все приложения, доступ к репозиториям — тоже.\r\n\r\nВозник кейс, когда все таски на мой стек были полным дерьмищем, за которое возьмется только безумец. Я — не безумец, и начал брать таски с тайпскриптом и реактом, потом с джавой. Все приложения делают примерно одно и тоже, но рассчитаны на разные платформы. Проблем у меня не возникало. \r\n\r\nВот я написал штуку, которая выбирает лучший впн сервер на шарпах, вот пошел делать то же самое на джаве. То же самое, точно таким же образом. Поначалу не придавал значения, но в какой-то момент не заметить закономерность было уже очень сложно.\r\n\r\nЯ просто делал одно и то же на разных языках программирования. Этот код был очень похожим, за исключением деталей, которые никак не влияют на решаемую задачу. Ведь бизнес не приходит ко мне со словами: «Эй Фил! Нам нужно использовать абстрактные классы, чтобы отобразить клиенту состояние впн соединения». Бизнес и пользователи хотят, чтобы девайс показал им картинку. Да и я на самом деле тоже просто хочу показать им эту картинку.\r\n\r\nНо я не могу. Нельзя просто сказать машине: делай то, что мне нужно. Пока еще я тот самый промежуточный интерпретатор, который превращает фразу «сделай хреновину» в команды, пока еще мне приходится детально и пошагово разъяснять процессору, куда и как класть долбаные байты. \r\n\r\nНо и я уже не работаю с байтами. Я работаю на очень абстрактном уровне со штуками, которые производят фабрику фабрик механизмов, которые управляют этими байтами. Там внизу есть железяка, и она устроена еще сложнее — я понятия не имею как, что там делается. Но оно делается, через сотню призм, о которых я тоже не имею никакого понятия. Половину того, что я хочу сказать машине, она «додумывает» сама, и я не знаю, как именно.\r\n\r\nЯ как будто запаял капот автомобиля и стал чинить его через выхлопную трубу, которая становится с каждым годом все длиннее и длиннее, и однажды, чтобы починить двигатель, мне просто придется кричать в трубу, а не лезть руками.\r\n\r\nДотнетный компиль превращает мой сишарп в промежуточный язык (IL), который едет на машину к клиенту, где в свою очередь другой дотнетный компиль (который just-in-time) на лету превращает мой IL в платформоспецифичный код, который в свою очередь скармливается процессору…\r\n\r\nИ где-то там все мои формальные описания, все различия между ЯПами стираются, и делают одно и то же. На пальцах:\r\n\r\nЯ знаю, что процессор знает команду O1. Получив ее, он пульнет электричеством во встроенный микродинамик, у того что-то где-то перемкнет и раздастся писк.\r\n\r\nИ вот я на сишарпе пишу:\r\n\r\nusing System;\r\nConsole.Beep(500,500);\r\n\r\nЭта строка у меня превратится в О1\r\n\r\nЯ пишу на плюсах:\r\n\r\n#include <windows.h>\r\n\r\nBeep(500,500);\r\n\r\nИ она тоже превратится в О1.\r\n\r\nЯ что, должен думать, почему здесь System.Console, а там windows.h? Но мой мозг это запоминает, а таких специфичных деталей дофига, они совсем разные. Рано или поздно деталей становится так много, что мой выбор ЯПа становится не логическим, а просто потому что мне так больше нравится.\r\n\r\nНа прошлой работе меня заставили писать код с ограничениями, потому что под ним стоял не очень умный транспилятор. Мне рассказывали как давным-давно делали либу на сишарпе, а когда поняли, что упускают прибыль, решили делать еще и на джаве и на плюсах. Но кода к тому моменту было так много, что решили — дешевле будет нанять команду разрабов, которые напишут превращатель сишарпа в джаву и плюсы.\r\n\r\nИ это сработало. С кучей оговорок и проблем, но они просто автоматически превращали сишарп код в джава код, и пуляли либу клиентам. Все эти убеждения, что «каждый язык решает свою задачу», выбросили на помойку.\r\n\r\nИ вот сидя над дизайном очередного модуля, я подумал — а что бы сказал старина фон Нейман и его команда, когда услышали о моих проблемах? Те самые парни, которые конструировали свои принципы хранения данных и доказывали идиотам, что двоичная система для машин лучше, чем десятичная.\r\n\r\nОни бы не офигели от нашего количества абстракций ради абстракций? Смогли бы принять, что в 2019 все чаще выбирают абстракции чисто эстетически и этим размывают связь с выполнением на машине. \r\n\r\nПроцессор, компьютер — это очень, очень сложная штука. А мы свели это к простым абстракциям, чтобы думать, что якобы этим управляем. В итоге ни один сегодняшний софтверный инженер не понимает, как устроена машина, но, так как он вроде бы может этим управлять, ему кажется, что машина ему повинуется, и он крутой. Это иллюзия.\r\n\r\nКаждый раз, когда очередной стартапер думает «да че там случится с моей нодой, когда я все перевезу с x86 на ARM. Вся эта низкоуровневая фигня меня не касается», мы все дальше и дальше от реального контроля над задачами. Язык общения с машиной стал почти человеческим. Но похоже, это не работает так, как задумано.\r\n\r\n\r\n\r\nПочти любой из распространенных сегодня ЯПов продается, как инструмент решения всех проблем. Но это не работает. Сначала появляется инструмент, который делает жизнь проще при решении какой-нибудь одной маленькой задачи, все начинают его хайпить, создают ему инфраструктуру, делают все, что бы он стал применим везде — и вот у нас очередной чересчур сложный и слишком абстрактный инструмент, который все делает плохо. Кто-то где-то уже пилит новый ему на замену. Чтобы запутать все еще больше.\r\n\r\nОдин мой друг-гуманитарий (эй, уберите револьверы, мы же все с вами притворяемся, что с гуманитариями можно дружить, я — не исключение) написал рассказ. Заявил мне, что я, как друг, должен его прочитать. Я долго отлынивал. Но он меня достал, и я прочитал. И это оказался один из тех случаев, когда гуманитарные знания улучшили мои навыки разработчика. Смотрите.\r\n\r\nСам рассказ — фантастика. В центре дизайна проблема словесного взаимодействия между людьми. Там весь мир заболел болезнью, когда тебе кажется, что ты говоришь нормально, но окружающие слышат какую-то бессвязную чепуху. Рассказ в итоге об этом — как с помощью языка передавать свое восприятие, и что делать, если языка у тебя нет. Я и раньше думал о том, что между языком программирования и естественными языками можно проводить параллели, но думал, конечно не всерьез. Прочитал и задумался покрепче. \r\n\r\nКогда бизнес приносит мне задачу «Эй, Фил, сделай хреновину», что вообще происходит у меня в мозгу? Сколько ступенек интерпретации проходит, пока звуковая волна, отскакивая от моих ушей, превращается в сигналы и пробегает по нейронам мозга куда надо. Я об этом вообще не думаю, это происходит само.\r\n\r\nИ из-за этой неосознанности, из-за того, что я спокойно отдал мозгу автоматически интерпретировать «услышанное» в «понятое» — появилась куча багов, которые я не контролирую. Вот менеджер три часа объясняет мне бизнес задачу, а я ухожу от него с одной мыслью: «что за буллшит он нес!? Пусть напишет в джире, тогда и сделаю». \r\n\r\nСколько бы он ни говорил, так и не смог скомпилировать в меня свое видение, хотя сам себе в голове он может его донести за секунду.\r\nПотому что в наших мозгах наросла куча абстракций за миллионы лет. Появились одновременно и понимание, и грандиознейшее непонимание, с которым мы ничего не можем сделать. \r\n\r\nЯзыкам программирования еще нет и века, а слой абстракций между моим программированием и реальной работой железяк уже пугающе толстый. И когда я об этом подумал, мне стало тревожно, потому что контроль уходит.\r\n\r\nКогда лет через 20 абстракции станут еще на три порядка толще, а ЯПы будут почти человеческими, я уже не буду понимать, как компьютер выполнит мою просьбу, как он ее поймет. Потому что я полностью автоматизирую процесс его понимания.\r\n\r\nИ когда кто-то напишет очередное «мое разочарование в софте» и будет жаловаться, какое все громоздкое, неправильное и неповоротливое — с этим уже ничего нельзя будет сделать. Стремясь упростить свою жизнь, мы теряем над ней контроль. А это очень плохо. \r\n\r\nНо еще больше я боюсь другого. Высокоуровневые ЯПы настолько изменят мое мышление, что мысль «все плохо» просто физически не сможет зародиться в моей голове. Я точно уверен, что естественный язык, на котором я говорю, очень серьезно влияет на мое сознание. Если я русский, то десять поколений моих предков диктуют мне, как я должен думать с помощью языка, который я от них унаследовал. Языка, который устроен, например, так, что в любом предложении о случившейся проблеме — должен быть виноватый. Даже если я говорю «случилась херня» — виновата все равно херня. А, например, в испанском такого нет. Случилось и случилось (и даже сейчас по-русски подразумевается, что случилось «что-то»). \r\n\r\nЯ проговорил на русском четверть века каждый день — и теперь физически не верю в случайности. Или верю, что мужчины важнее женщин, потому что весь язык завязан на мужском роде. Мою статью перевели на английский, в комменты пришли американцы с просьбами заменить местоимения на гендерно-нейтральные — и я не знаю, что делать со своим возмущением. А у немцев, например, таких проблем нет. Их язык давно гендерно-гибкий. И там все ходят в одну баню, а страной руководит женщина.\r\n\r\nЯзык управляет мной не меньше, чем я им, и это не тот выбор, который бы делал я сам. Его за меня сделали другие люди. Но естественный язык — штука древняя и неповоротливая, я не могу взять, и надавать по щам его создателям если мне в нем что-то не нравится. И не могу его сменить, по крайней мере легко. \r\n\r\nС программированием почти также. Выучил ООП-язык, потом посмотрел на функциональный и сломал себе мозг. ЯП — это не просто инструмент, который тебе служит, а крупная часть твоей жизни, которая во многом определяет твое мышление не только на работе. Потому что на самом глубоком уровне, ЯП влияет не на то, как задача будет сделана, а на то, как ты о ней думаешь. Это не гаечный ключ у тебя в гараже — это кусок твоего сознания. \r\n\r\nИ чем абстрактнее становится язык, тем сильнее из твоего мышления вымывается его реальная природа — контролировать электричество в железе. Все эти картинки у тебя на мониторе, циферки, библиотеки, анимации — они не настоящие. Настоящее только электричество. Только железо. Я не готов потерять над ним контроль.', '2019-06-12 18:00:00', '2019-06-13 05:58:26');

-- --------------------------------------------------------

--
-- Структура таблицы `post_tags`
--

CREATE TABLE `post_tags` (
  `id` int(11) NOT NULL,
  `post_id` int(10) UNSIGNED NOT NULL,
  `tag_id` int(10) UNSIGNED NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `post_tags`
--

INSERT INTO `post_tags` (`id`, `post_id`, `tag_id`, `created_at`, `updated_at`) VALUES
(3, 3, 11, '2019-06-05 08:46:31', '2019-06-05 08:46:31'),
(4, 4, 1, '2019-06-05 09:25:42', '2019-06-05 09:25:42'),
(5, 5, 2, '2019-06-05 09:26:45', '2019-06-05 09:26:45'),
(7, 7, 8, '2019-06-05 09:31:04', '2019-06-05 09:31:04'),
(9, 9, 1, '2019-06-13 05:38:36', '2019-06-13 05:38:36'),
(10, 10, 1, '2019-06-13 05:58:26', '2019-06-13 05:58:26'),
(11, 10, 2, '2019-06-13 05:58:26', '2019-06-13 05:58:26'),
(12, 10, 8, '2019-06-13 05:58:26', '2019-06-13 05:58:26'),
(13, 10, 11, '2019-06-13 05:58:26', '2019-06-13 05:58:26');

-- --------------------------------------------------------

--
-- Структура таблицы `tags`
--

CREATE TABLE `tags` (
  `id` int(10) UNSIGNED NOT NULL,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `tags`
--

INSERT INTO `tags` (`id`, `name`, `created_at`, `updated_at`) VALUES
(1, 'php', NULL, NULL),
(2, 'java', NULL, NULL),
(8, 'python', NULL, NULL),
(11, 'science', NULL, NULL);

-- --------------------------------------------------------

--
-- Структура таблицы `users`
--

CREATE TABLE `users` (
  `id` bigint(20) UNSIGNED NOT NULL,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email_verified_at` timestamp NULL DEFAULT NULL,
  `password` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `remember_token` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `migrations`
--
ALTER TABLE `migrations`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `password_resets`
--
ALTER TABLE `password_resets`
  ADD KEY `password_resets_email_index` (`email`);

--
-- Индексы таблицы `posts`
--
ALTER TABLE `posts`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `post_tags`
--
ALTER TABLE `post_tags`
  ADD PRIMARY KEY (`id`),
  ADD KEY `post_tags_post_id_index` (`post_id`),
  ADD KEY `post_tags_tag_id_index` (`tag_id`);

--
-- Индексы таблицы `tags`
--
ALTER TABLE `tags`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `name` (`name`);

--
-- Индексы таблицы `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `users_email_unique` (`email`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `migrations`
--
ALTER TABLE `migrations`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=12;
--
-- AUTO_INCREMENT для таблицы `posts`
--
ALTER TABLE `posts`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;
--
-- AUTO_INCREMENT для таблицы `post_tags`
--
ALTER TABLE `post_tags`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=14;
--
-- AUTO_INCREMENT для таблицы `tags`
--
ALTER TABLE `tags`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=12;
--
-- AUTO_INCREMENT для таблицы `users`
--
ALTER TABLE `users`
  MODIFY `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT;
--
-- Ограничения внешнего ключа сохраненных таблиц
--

--
-- Ограничения внешнего ключа таблицы `post_tags`
--
ALTER TABLE `post_tags`
  ADD CONSTRAINT `post_tags_post_id_foreign` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `post_tags_tag_id_foreign` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`) ON DELETE CASCADE;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
